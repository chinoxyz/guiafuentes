\documentclass{article}
\usepackage{minted}
\usepackage{listings}
\usepackage{fullpage}

\usepackage{tikz}
\usepackage{multicol}
\usepackage{latexsym}
\usepackage{array}
\usepackage[english,spanish]{babel}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{xcolor}
\usepackage{amsmath}
\pagestyle{empty}

\begin{document}



\title{Gu\'ia de Maratones \\ Universidad Sim\'on Bol\'ivar}

\author{
S\'anchez, Pi\~nero, De Abreu, Colmenares}

\date{Mayo 27, 2013}

\maketitle

\thispagestyle{empty}

\pagebreak

%\section{GRAFOS}

\section*{UNION FIND}
Implementaci\'on de Conjuntos Disjuntos
\inputminted[]{c++}{algorithms/UNIONFIND.cpp}
\newpage

\section*{2SAT}
1) Construct the implication graph of the instance, and find its strongly 
connected components using any of the known linear-time algorithms for strong connectivity analysis.

2) Check whether any strongly connected component contains both a variable 
and its negation. If so, report that the instance is not satisfiable and halt.

3) Construct the condensation of the implication graph, a smaller graph that 
has one vertex for each strongly connected component, and an edge from 
component i to component j whenever the implication graph contains an 
edge uv such that u belongs to component i and v belongs to component j. 
The condensation is automatically a directed acyclic graph and, like the 
implication graph from which it was formed, it is skew-symmetric.

4) Topologically order the vertices of the condensation; the order 
in which the components are generated by Kosaraju's algorithm is 
automatically a topological ordering.

5) For each component in this order, if its variables do not already have 
truth assignments, set all the terms in the component to be false. 
This also causes all of the terms in the complementary component to be set to true.

\section*{CICLO EULERIANO}
Para saber si un grafo tiene un ciclo euleriano, basta con probar
que todo nodo tiene grado par.
Este algoritmo te obtiene el ciclo euleriano resultante.
\inputminted[]{c++}{algorithms/EULERIANCYCLE.cpp}
\newpage

\section*{TARJAN}
Tarjan for undirected graphs (Cacol)
\inputminted[]{c++}{algorithms/TARJAN.cpp}
\newpage

\section*{TARJAN2*}
Tarjan for directed graphs (Cacol)
\inputminted[]{c++}{algorithms/TARJAN2.cpp}
\newpage


\section*{FLOYD}
O(n*n*n)
n - numero de nodos
cost - matriz de costos(infinito si no hay arco)
\inputminted[]{c++}{algorithms/FLOYD.cpp}

\section*{BELLMAN-FORD}
O(n*m)
n - numero de nodos
cost - matriz de costos(infinito si no hay arco)
\inputminted[]{c++}{algorithms/BELLMAN.cpp}
\newpage

\section*{LOWEST COMMON ANCESTOR}
\inputminted[]{c++}{algorithms/LCA.cpp}
\newpage

\section*{Heavy Light Decomposition*}
\inputminted[]{c++}{algorithms/HeavyLight.cpp}
\newpage


\section*{MAX FLOW - DINIC}
\inputminted[]{c++}{algorithms/DINIC.cpp}
\newpage

\section*{MAX FLOW - MIN COST}
(Standford)
\inputminted[]{c++}{algorithms/MAXFLOWMINCOST.cpp}
\newpage

\section*{MAX FLOW - MIN CUT}
(Standford)
\inputminted[]{c++}{algorithms/MINCUT.cpp}
\newpage


\section*{MAX BIPARTITE MATCHING - FORD FUKERSON}
Se debe colocar M suficientemente grande para que quepa el sumidero.
Se debe construir salida(Lista de adyacencias). Y se deben colocar las capacidades.
q es un separador entre los conjuntos
\inputminted[]{c++}{algorithms/MAXBIPARTITEMATCHINGFF.cpp}
\newpage

\section*{TEOREMA DE KONING - FORD FUKERSON}
Se debe usar el algoritmo de Max Bipartite Matching - ford fukerson. \newline
solx son las rectas verticales y soly son las rectas horizontales
\inputminted[]{c++}{algorithms/KONING.cpp}
\newpage

\section*{MAXBIPARTITE MATCHING - HOPCROFT KARP}
n: n\'umero de nodos a la izquierda, numerados de 1 a n
m: n\'umero de nodos a la derecha, numerados de n+1 a n+m
G = NIL[0] ∪ G1[G[1---n]] ∪ G2[G[n+1---n+m]]
\inputminted[]{c++}{algorithms/MAXBIPARTITEMATCHINGHK.cpp}
\newpage

\section*{MAX MATCHING - GABOW}
\inputminted[]{c++}{algorithms/GABOW.cpp}
\newpage

\section*{MAX BIPARTITE MATCHING MIN COST}
Algoritmo H\'ungaro. (STANDFORD)
\inputminted[]{c++}{algorithms/HUNGARIAN2.cpp}
\newpage


\section*{STABLE MARRIAGE PROBLEM}
Problema del matrimonio estable.
Realiza matchings de hombres y mujeres tal que nunca nadie va a enga\~nar a su pareja,
porque prefiere a su pareja que al otro.
\inputminted[]{c++}{algorithms/STABLEMARRIAGE.cpp}
\newpage

%\section{ESTRUCTURAS}

\section*{MEDIAN OF TWO ARRAYS}
\inputminted[]{c++}{algorithms/MEDIAN.cpp}
\newpage

\section*{AVL TREE*}
Answer query number of nodes greater than k.
\inputminted[]{c++}{algorithms/AVL.cpp}
\newpage

\section*{Binary Indexed Tree}
Binary Index Tree de una dimensi\'on. (Cacol)
\inputminted[]{c++}{algorithms/BIT1D.cpp}
\newpage

\section*{Binary Indexed Tree 2D}
Binary Index Tree de dos dimensiones.
\inputminted[]{c++}{algorithms/BIT2D.cpp}
\newpage


\section*{RANGE TREE*}
Range tree general.
\inputminted[]{c++}{algorithms/RANGETREE.cpp}
\newpage

\section*{RANGE TREE LAZY PROPAGATION*}
Range tree general con lazy propagation.
\inputminted[]{c++}{algorithms/RANGETREELAZY.cpp}
\newpage

%\section{STRINGS}

\section*{KMP}
Retorna las posiciones donde ocurren los matches.
Cortes\'ia de Chococontest.
\inputminted[]{c++}{algorithms/KMP.cpp}
\newpage

\section*{RABIN KARP*}
Chequea si k substring de s.
\inputminted[]{c++}{algorithms/RABINKARP.cpp}
\newpage

\section*{AHO CORASICK*}
\inputminted[]{c++}{algorithms/AHO.cpp}
\newpage

\section*{SUFFIX ARRAY}
Construye el arreglo de sufijos.
\inputminted[]{c++}{algorithms/SUFFIXARRAY.cpp}
\newpage

\section*{SUFFIX ARRAY}
Construye el arreglo de sufijos. (cacol)
\inputminted[]{c++}{algorithms/SUFFIX.cpp}
\newpage

\section*{SUFFIX ARRAY - MAX SUBSTRING}
\inputminted[]{c++}{algorithms/MAXSUBSTRING.cpp}
\newpage

%\section{NUMEROS}

\section*{PI}
\inputminted[]{c++}{algorithms/PI.cpp}

\section*{DETERMINANTE}
Codigo para el calculo del determinante de una matriz NxN
\inputminted[]{c++}{algorithms/DETERMINANT.cpp}
\newpage

\section*{M\'ETODO DE SIMPSON}
F\'ormula:
 Integral de a hasta b de $f(x) dx = ((b-a)/6) * [f(a) + 4f((a+b)/2) + f(b)]$
 
En el caso de que el intervalo [a,b] no sea lo suficientemente peque\~no, el error al calcular la integral puede ser muy grande. 
Para ello, se recurre a la f\'ormula compuesta de Simpson. Se divide el intervalo [a,b] en n subintervalos iguales (con n par), de manera que  $x_i = a + ih$, 
donde  $h = (b-a)/n$ para i = 0, 1, ..., n.

Aplicando la Regla de Simpson a cada subintervalo  [$x_{j-1}$,$x_{j+1}$], :  j=1,3,5, ..., n-1,  tenemos:

 Integral de $x_{j-1}$ hasta $x_{j+1}$ de 
 
 $f(x)dx = (x_{j+1}-x_{j-1})/3 * [ f(x_{j-1}) + 4f(x_j)+ f(x_{j+1}) ]$.

Sumando las integrales de todos los subintervalos, llegamos a que:

 Integral de a hasta b de 
 
 $f(x) dx = (h/3) [ f(x_0)+ 2 * sum_{j=1}^{n/2-1}( f(x_{2j}) ) + 4*sum_{j=1}^{n/2}( f(x_{2j-1})+ f(x_n) ) ]$




\section*{N\'UMEROS DE MOTSKIN}

Formula: 
   - Recursiva: 
   
   $M_(n+1) =  M_n + sum [ i=0; n-1 ] (M_i*M_(n-1-i)) = (2n+3/n+3)M_n + (3n/n+3)M_(n-1)$
   - Coeficientes binomiales y N\'umeros de Catalan: 
   
   $sum [i=0; floor(n/2)]( n , 2k ) C_k$
   
Aplicaciones:
   - N\'umero de maneras diferentes de dibujar cuerdas que no se intersecten enntre n puntos en un circulo.
   - El n\'umero de secuencias de enteros positivos de longitud n-1 en donde el elemento inicial y final sean 1 o 2or 2, y que la diferencia entre dos elementos consecutivos sea -1, 0 o 1.
   - Teniendo el cuadrante superior derecho de un plano, el n\'umero Motzkin de n da el n\'umero de rutas desde la coordena (0,0) hasta la coordenada(n, 0) en n pasos
     si se permite s\'olo moverse a la derecha (arriba,abajo, en frente) pero se prohibe que se baje del eje y=0.
\newpage

\section*{COMBINATORIO}
Calcula el combinatorio de n en k
\inputminted[]{c++}{algorithms/COMBDP.cpp}

\section*{N\'UMEROS DE CATAL\'AN}
Cn = (2n, n) - (2n, n-1)
Aplicaciones:

Numero de palabras de Dyck de longitud 2n. Una palabra de Dyck es una cadena de caracteres que consiste en n Xs y n Ys de forma que no haya ning\'un segmento inicial que tenga m\'as Ys que Xs

Reinterpretando el s\'imbolo X como un par\'entesis abierto y la Y como un par\'entesis cerrado, Cn cuenta el n\'umero de expresiones que contienen n pares de par\'entesis correctamente colocados



\section*{MAXIMO COMUN DIVISOR}
Te calcula el m\'aximo com\'un divisor entre dos enteros.
\inputminted[]{c++}{algorithms/GCD.cpp}

\section*{MAXIMO COMUN DIVISOR EXTENDIDO}
Resuelve la siguiente ecuaci\'on:
ax + by = gcd(a,b)
donde:
r1 = x, r2 = y
\inputminted[]{c++}{algorithms/EXTENDEDGCD.cpp}
\newpage

\section*{INVERSO MULTIPLICATIVO}
Calcula el inverso multiplicativo de a m\'odulo m.
Cuidado, gcd(a,m) debe ser 1.
\inputminted[]{c++}{algorithms/MULTIPLICATIVEINVERSE.cpp}

\section*{FERMAT LITTLE THEOREM}
\inputminted[]{c++}{algorithms/FERMAT.cpp}
\newpage

\section*{GAUSS JORDAN}
(standford)
\inputminted[]{c++}{algorithms/GAUSSJORDAN.cpp}
\newpage

\section*{TEOREMA CHINO DEL RESTO}
Dado a[i] enteros y b[i] modulos resuelve el m\'inimo com\'un m\'ultiplo entre ecuaciones modulares.
Se deben crear y[i] y z[i] arreglos auxiliares.
n es la cantidad de ecuaciones y m es la multiplicaci\'on de todos los b[i].
Para usar este algoritmo se debe cumplir que gcd(b[i], b[j]) es 1.
\inputminted[]{c++}{algorithms/CRT.cpp}

\section*{TEOREMA CHINO DEL RESTO EXTENDIDO}
Dados a1 n1 a2 y n2 retorna True si existe una soluci\'on a las ecuaciones dando como resultado a0 y n0.
Retorna False en caso contrario.
\inputminted[]{c++}{algorithms/CRTE.cpp}
\newpage


\section*{Transformada r\'apida de Fourier*}
\inputminted[]{c++}{algorithms/FFT.cpp}
\newpage

\section*{Suma de digitos base m*}
\inputminted[]{c++}{algorithms/DIGITSUM.cpp}
\newpage

\section*{EXPONENCIACI\'ON R\'APIDA}
Resuelve (a ** b) % m
\inputminted[]{c++}{algorithms/EXP.cpp}


\section*{TEST DE MILLER}
Verifica si un n\'umero es primo.
Colocarle 20 iteraciones.
\inputminted[]{c++}{algorithms/MILLERTEST.cpp}
\newpage

\section*{SIEVE ERATOSTELES}
\inputminted[]{c++}{algorithms/SIEVE.cpp}
\newpage

%\section{GEOMETRIA}

\section*{Point 2D}
\inputminted[]{c++}{algorithms/P2D.cpp}
\newpage

\section*{Point 2D extensiones}
\inputminted[]{c++}{algorithms/P2D2.cpp}
\newpage

\section*{Point in Polygon (Winding Number)}
\inputminted[]{c++}{algorithms/POINTINPOLYGON.cpp}
\newpage

\section*{Centroide}
\inputminted[]{c++}{algorithms/CENTROIDE.cpp}
\newpage

\section*{\'Area Pol\'igono}
Retorna el \'area del pol\'igono con puntos p.
\inputminted[]{c++}{algorithms/AREAPOLYGON.cpp}
\newpage

\section*{GEOMETRIA}
FUNCIONES GEOMETRICAS (STANDFORD)
\inputminted[]{c++}{algorithms/GEOMETRY.cpp}
\newpage


\section*{CONVEX HULL MONOTONE CHAIN}
Para que trabaje con puntos colineales basta con colocar que el producto cruz es menor a cero.
Cuidado: Repite el primer punto al final.
\inputminted[]{c++}{algorithms/CONVEXHULLMC.cpp}
\newpage

\section*{MIN MAX AREA OF TRIANGLES*}
Dado un vector de puntos, devuelve la m\'inima y m\'axima area de los tri\'angulos.
\inputminted[]{c++}{algorithms/Triangles.cpp}
\newpage

\end{document}
